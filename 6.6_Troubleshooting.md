# 6.6 Troubleshooting

# Задание №1

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

   - напишите список операций, которые вы будете производить для остановки запроса пользователя
   
Ответ:

   Нам нужно найти процесс opid и затем завершить его:
   ```
   db.currentOp({
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     })
     
   Далее получаем ответ, в котором ищем "opid" : 1111.
   Используя операцию db.killOP(1111), завершаем зависший процесс.
   ```
   - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

   ```
   Можно использовать  public MongoCursor::maxTimeMS ( int $ms ) : MongoCursor. $ms - время в секундах, при котором сервер    
   MongoDB прерывает длительные запросы. 
   ```
   
# Задание №2

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

  - сначала рост отношения записанных значений к истекшим
  - Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

```
Происходит задержка , вызванная истечением срока действия ключей. Redis удаляет ключи с истекшим сроком действия двумя способами:
- Ленивым - это когда истекает срок действия ключа, когда он запрашивается командой, но оказывается, что срок его действия уже истек.
- Активным - когда истекает срок действия нескольких ключей каждые 100 миллисекунд.

Активный метод предназначен для адаптации. Цикл истечения срока действия запускается каждые 100 миллисекунд (10 раз в секунду) и выполняет следующие действия:

- Образцы ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP ключей, удаление всех ключей, срок действия которых уже истек.
- Если было обнаружено, что более 25% ключей истекли, повторите.

По итогу алгоритм является адаптивным и будет зацикливаться, если обнаружит, что более 25% ключей уже истекли в наборе выбранных ключей. Но, учитывая, что мы запускаем алгоритм десять раз в секунду, это означает, что неудачное событие для более чем 25% ключей в нашей случайной выборке истекает, по крайней мере, в ту же секунду. Это означает, что если в базе данных много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% от текущего набора ключей с истекшим сроком действия, Redis может заблокировать операции записи, чтобы процент ключей, срок действия которых уже истек, был ниже 25%.
```

# Задание №3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
```
1. Из-за слишком большого количества запросов
2. Когда клиент пытается установить первоначальное соединение с сервером. Возможно из-за большого расстояния между сервером и клиентом, или медленным соединением
3. Возможно, возникла проблема со BLOB значениями, которые больше, чем max_allowed_packet, что может вызвать эту ошибку у некоторых клиентов
```

Какие пути решения данной проблемы вы можете предложить?
```
1. Следует попробовать увеличить net_read_timeout значение по умолчанию, для увеличения времени ожидания
2. Мы можем увеличить значение connect_timeout. Мы можете определить, столкнулись ли с проблемой из-за этого, используя SHOW GLOBAL STATUS LIKE 'Aborted_connects'. Оно увеличивается на единицу при каждой первоначальной попытке подключения, которую прерывает сервер
3. Если мы увидим в логах ошибку ER_NET_PACKET_TOO_LARGE, значит нам нужно увеличить значение max_allowed_packet.
```
# Задание №4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

```
postmaster invoked oom-killer
```

Как вы думаете, что происходит?

```
Ошибка postmaster invoked oom-killer указывает на то, что PostgreSQL не хватает оперативной памяти. 
```

Как бы вы решили данную проблему?

```
Нужно проанализировать, если физически не хватает оперативной памяти на сервере, то её нужно добавлять, либо переносить базу на сервер с большим объёмом оперативной памяти. Если же оперативной памяти хватает, то нужно изменить значение максимального потребления ОЗУ в файле конфигурации sysctl.conf.
```





